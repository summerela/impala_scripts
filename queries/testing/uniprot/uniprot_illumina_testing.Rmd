---
title: "uniprot_testing"
output: html_document
---
##Purpose: 
Testing uniprot gene annotation queries. 

##Test plan
The first 100000 rows of  p7_ptb.illumina_variant and public_hg19.uniprot will be saved as p7dev.illumina_test and p7dev.uniprot_test on impala and run through tests to compare results between R and impala queries. 

After initial check to make sure tables in R and impala are both 100,000 rows:

Imapala:   
1. Run coding gene annotation query on impala  
2. Count total records returned  
3. Count number of unique features (cds, exon, etc.)  
4. Compare random sample of genes returned  
5. Count unique transcript names reported  

Compare numbers returned in imapala with numbers returned by R:   
1. Read in illumina and uniprot subset tables  
2. Get gene name from uniprot where vcf position falls between uni_start and uni_stop  
3. Compare counts with impala  

##Testing Query to find variants in uniprot genes
The following tests were run on p7dev.illumina_test and p7dev.uniprot_test tables on impala. 

###Finding variants on impala
The following query was run to count rows returned on the illumina_test and uniprot_test test tables:

```sql 
SELECT COUNT(*)
FROM p7dev.illumina_test as vcf, p7dev.uniprot_test as uni
WHERE vcf.filter = "PASS"  
AND vcf.chromosome = uni.chromosome  
AND vcf.position BETWEEN uni.start AND uni.stop  
```
450 rows were returned. 

###Downloading variants into R
The following query was run to return results for later comparison with R results: 
```sql
SELECT vcf.sample_id as vcf_sample_id, vcf.chromosome as vcf_chrom, vcf.position as vcf_pos,vcf.ref as vcf_ref, vcf.alt as vcf_alt, vcf.id as vcf_rsID, uni.start as uniprot_start, uni.stop as uniprot_end, uni.feature, uni.gene_name as uniprot_gene_name, uni.gene_id as uniprot_geneid, uni.gene_biotype as uniprot_gene_biotype, uni.transcript_name as uniprot_tx_name,uni.transcript_id as uniprot_trans_id, uni.exon_id as uniprot_exonid, uni.strand as uniprot_strand
FROM p7dev.illumina_test as vcf, p7dev.uniprot_test as uni
WHERE vcf.filter = "PASS"  
AND vcf.chromosome = uni.chromosome  
AND vcf.position BETWEEN uni.start AND uni.stop  
```
This file was then read into R to uniure validity of queries used for tesing: 

```{r read_results}
#read in results table
uni_results = read.csv("./query_result_uniprot.csv")
```

###Reading data into R for comparison

The subset tables were read into R: 

```{r read_in_subset}
suppressMessages(library(RODBC))

#connect using the DSN name you created on your machine
conn <- odbcConnect("Impala DSN")

vcf = sqlFetch(conn, "p7dev.illumina_test")
head(vcf)
dim(vcf)
uni = sqlFetch(conn, "p7dev.uniprot_test")
head(uni)
dim(uni)
```



The following was run in R: 
```{r count_features_R}
suppressMessages(library(GenomicRanges))
suppressMessages(library(IRanges))

##subset for only vcf rows that passed filtering
vcf_pass = vcf[which(vcf$filter == "PASS"),]
        
#create GRanges objects for comparison
vars = with(vcf_pass, GRanges(seqnames=vcf_pass$chromosome, 
                         ranges=IRanges(vcf_pass$pos, width=1, 
                                        names=paste(vcf_pass$sample_id, ":",vcf_pass$ref, ">", vcf_pass$alt, sep="")),rsID=vcf_pass$id, filter=vcf_pass$filter, qual=vcf_pass$qual, sample_id=vcf_pass$sample_id))

genes = with(uni, GRanges(seqnames=uni$chromosome, 
                         ranges=IRanges(uni$start, uni$stop,names=uni$gene_id),
                                        feature=uni$feature, trans_id=uni$transcript_id, gene_id=uni$gene_id, gene_name=uni$gene_name, trans_name=uni$transcript_name, exon=uni$exon_id))

##find variants that fall in gene regions
match = suppressWarnings(findOverlaps(vars, genes))

##turn results into a data frame
match.df = data.frame(sample_id = as.character(mcols(vars)$sample_id)[queryHits(match)],
                      chrom = seqnames(vars)[queryHits(match)],
                      pos = as.data.frame(ranges(vars))$start[queryHits(match)],
                      variant = as.character(lapply(strsplit(as.character(names(vars)[queryHits(match)]), ":"), function(x) x[2])),
                      rsId = as.character(mcols(vars)$rsID)[queryHits(match)],
                      gene_name = mcols(genes)$gene_name[subjectHits(match)],
                      gene_id = names(genes)[subjectHits(match)],
                      trans_name = mcols(genes)$trans_name[subjectHits(match)],
                      trans_id = mcols(genes)$trans_id[subjectHits(match)],
                      exon_id = mcols(genes)$exon[subjectHits(match)],
                      feature = mcols(genes)$feature[subjectHits(match)],
                      stringsAsFactors=F)

#450 rows, same as impala query                                  
head(match.df)
dim(match.df)   

```

###compare Impala Results file and R generated results
```{r compare_results}
#add variant column to impala results
uni_results$variant = paste(uni_results$vcf_ref, ">", uni_results$vcf_alt, sep="")
#coerce to same structure as match.df for comparison
uni.df = uni_results[c(1,2,3,17,6,10,11,13,14,15,9)]
colnames(uni.df) = colnames(match.df)

#order both data frames for matching
uni.df = uni.df[with(uni.df, order(sample_id, chrom, pos, variant, gene_name, gene_id, trans_name, trans_id, exon_id, feature)),]
match.df = match.df[with(match.df, order(sample_id, chrom, pos, variant, gene_name, trans_name, trans_id, exon_id, feature)),]

#coercing columns to same class for comparison
i = sapply(uni.df, is.factor)
uni.df[i] = lapply(uni.df[i], as.character)

j = sapply(match.df, is.factor)
match.df[j] = lapply(match.df[j], as.character)

#removing rownames for matching
rownames(match.df)= NULL
rownames(uni.df) = NULL

#rsID column is "NULL" in one table, "NA" in the other
uni.df$rsId = gsub("NULL", "NA", uni.df$rsId)

#compare data frames
which(match.df != uni.df, arr.ind=TRUE)

#0 results returned  = data frames are identical

```

###Count unique gene features returned
Imapala: 

This following query was run on impala, showing two feature categories "CDS" and "exon": 
```sql
SELECT COUNT(DISTINCT uni.feature)
FROM p7dev.illumina_test as vcf, p7dev.uniprot_test as uni
WHERE vcf.filter = "PASS"  
AND vcf.chromosome = uni.chromosome  
AND vcf.position BETWEEN uni.start AND uni.stop  
```

R on impala results: 

The following R query run on the impala results generated above shows that there are two features found in the results, "CDS" and "exon". 

```{r count_results_features}
str(uni_results$feature)
```

R results: 
Results from the R-generated data also show to features, "CDS" and "exon". 

```{r count_R_features}
unique(match.df$feature)

```

###Compare random sample of genes returned
First, we'll grab a random sample of genes from R and examine them on each platform: 
```{r rand_genes}
#rand_genes = sample(unique(match.df$gene_name), 5)
#the above generated the following list, saving as fixed ("RMRPP1","PPIAP13","NDST2","RP11-574K11.8","RPL39P25")
rand_genes = c("RMRPP1","PPIAP13","NDST2","RP11-574K11.8","RPL39P25")
```

How many rows are returned for these genes in R? 
```{r count_rand_genes}

rand_match = match.df[(match.df$gene_name %in% rand_genes),]
dim(rand_match)
rand_match

```

How many of these genes are in impala results? 

```{r count_rand_impala_results}

match_imp_results = uni.df[(uni.df$gene_name %in% rand_genes),]
dim(match_imp_results)
match_imp_results

##are the gene also the same in the imapla results?
which(rand_match != match_imp_results, arr.ind=TRUE)
#returns 0 mismatches
```


12 identical results are returned on impala: 
```sql
SELECT COUNT(*)
FROM p7dev.illumina_test as vcf, p7dev.uniprot_test as uni
WHERE vcf.filter = "PASS"  
AND vcf.chromosome = uni.chromosome  
AND vcf.position BETWEEN uni.start AND uni.stop 
AND uni.gene_name IN ("RMRPP1","PPIAP13","NDST2","RP11-574K11.8","RPL39P25")
```

###Query to find all variants in uniprot annotated regions
The results of above analysis were used to validate the following query that can be used to determine what regions a variant falls in and for futher annotation in finding amino acid changes:  

```sql 
SELECT vcf.sample_id as vcf_sample_id, vcf.chromosome as vcf_chrom, vcf.position as vcf_pos,vcf.ref as vcf_ref, vcf.alt as vcf_alt, vcf.id as vcf_rsID, uni.start as uniprot_start, uni.stop as uniprot_end, uni.feature, uni.gene_name as uniprot_gene_name, uni.gene_id as uniprot_geneid, uni.gene_biotype as uniprot_gene_biotype, uni.transcript_name as uniprot_tx_name,uni.transcript_id as uniprot_trans_id, uni.exon_id as uniprot_exonid, uni.strand as uniprot_strand
FROM p7_ptb.illumina_variant as vcf, public_hg19.uniprot_genes as uni  
WHERE vcf.filter = "PASS"  
AND vcf.chromosome = uni.chromosome  
AND vcf.position BETWEEN uni.start AND uni.stop  
```

This is equivalent to: 

```sql
SELECT vcf.sample_id as vcf_sample_id, vcf.chromosome as vcf_chrom, vcf.position as vcf_pos,vcf.ref as vcf_ref, vcf.alt as vcf_alt, vcf.id as vcf_rsID, uni.start as uniprot_start, uni.stop as uniprot_end, uni.feature, uni.gene_name as uniprot_gene_name, uni.gene_id as uniprot_geneid, uni.gene_biotype as uniprot_gene_biotype, uni.transcript_name as uniprot_tx_name,uni.transcript_id as uniprot_trans_id, uni.exon_id as uniprot_exonid, uni.strand as uniprot_strand
FROM p7dev.illumina_test as vcf
JOIN
p7dev.uniprot_test as uni
ON vcf.chromosome = uni.chromosome  
WHERE vcf.filter = "PASS"
AND vcf.position BETWEEN uni.start AND uni.stop 
```

##Query to find variants not in uniprot annotated regions
Results can be used to locate intergenic variants; downstream analysis can be used to find the two flanking genes, and distances between the variants and the flanking genes.


```sql
SELECT vcf.sample_id as vcf_sample_id, vcf.chromosome as vcf_chrom, vcf.position as vcf_pos, vcf.ref as vcf_ref, vcf.alt as vcf_alt, vcf.id as vcf_rsID, uni.start as uniprot_start, uni.stop as uniprot_end, uni.feature, uni.gene_name as uniprot_gene_name, uni.gene_id as uniprot_geneid, uni.gene_biotype as uniprot_gene_biotype, uni.transcript_name as uniprot_tx_name, uni.transcript_id as uniprot_trans_id, uni.exon_id as uniprot_exonid, uni.strand as uniprot_strand
FROM p7_ptb.illumina_variant as vcf, public_hg19.uniprot_genes as uni
WHERE NOT EXISTS(
  SELECT * 
  FROM p7_ptb.illumina_variant as vcf, public_hg19.uniprot_genes as uni  
  vcf.filter = "PASS"
  AND vcf.qual > 100
  AND vcf.chromosome = uni.chromosome
  AND vcf.position NOT BETWEEN uni.start AND uni.stop
  )
```
